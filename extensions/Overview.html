<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>Extensions to the PNG Third Edition Specification, Version 1.6.1</title>
  <meta content="NOTE-WD" name="w3c-status">
  <link href="https://www.w3.org/StyleSheets/TR/2021/W3C-DNOTE" rel="stylesheet">
  <meta content="Bikeshed version b25686b9f, updated Fri Mar 14 14:15:20 2025 -0700" name="generator">
  <link href="https://w3.org/TR/png-extensions/" rel="canonical">
  <link href="https://www.w3.org/2008/site/images/favicon.ico" rel="icon">
  <meta content="32113571711ea45fc4af71a810cd12bf5a17a60b" name="revision">
  <meta content="dark light" name="color-scheme">
  <link href="https://www.w3.org/StyleSheets/TR/2021/dark.css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css">
<style>
    span.chunk {
        font-family: Courier, monospace;
        color:green;
        font-weight:bold;
    }
</style>
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}
</style>
<style>/* Boilerplate: style-colors */
/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}
</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-selflinks */
:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* Boilerplate: style-syntax-highlighting */
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */

@media (prefers-color-scheme: dark) {
    .highlight:not(.idl) { background: rgba(255, 255, 255, .05); }

    c-[a] { color: #d33682 } /* Keyword.Declaration */
    c-[b] { color: #d33682 } /* Keyword.Type */
    c-[c] { color: #2aa198 } /* Comment */
    c-[d] { color: #2aa198 } /* Comment.Multiline */
    c-[e] { color: #268bd2 } /* Name.Attribute */
    c-[f] { color: #b58900 } /* Name.Tag */
    c-[g] { color: #cb4b16 } /* Name.Variable */
    c-[k] { color: #d33682 } /* Keyword */
    c-[l] { color: #657b83 } /* Literal */
    c-[m] { color: #657b83 } /* Literal.Number */
    c-[n] { color: #268bd2 } /* Name */
    c-[o] { color: #657b83 } /* Operator */
    c-[p] { color: #657b83 } /* Punctuation */
    c-[s] { color: #6c71c4 } /* Literal.String */
    c-[t] { color: #6c71c4 } /* Literal.String.Single */
    c-[u] { color: #6c71c4 } /* Literal.String.Double */
    c-[ch] { color: #2aa198 } /* Comment.Hashbang */
    c-[cp] { color: #2aa198 } /* Comment.Preproc */
    c-[cpf] { color: #2aa198 } /* Comment.PreprocFile */
    c-[c1] { color: #2aa198 } /* Comment.Single */
    c-[cs] { color: #2aa198 } /* Comment.Special */
    c-[kc] { color: #d33682 } /* Keyword.Constant */
    c-[kn] { color: #d33682 } /* Keyword.Namespace */
    c-[kp] { color: #d33682 } /* Keyword.Pseudo */
    c-[kr] { color: #d33682 } /* Keyword.Reserved */
    c-[ld] { color: #657b83 } /* Literal.Date */
    c-[nc] { color: #268bd2 } /* Name.Class */
    c-[no] { color: #268bd2 } /* Name.Constant */
    c-[nd] { color: #268bd2 } /* Name.Decorator */
    c-[ni] { color: #268bd2 } /* Name.Entity */
    c-[ne] { color: #268bd2 } /* Name.Exception */
    c-[nf] { color: #268bd2 } /* Name.Function */
    c-[nl] { color: #268bd2 } /* Name.Label */
    c-[nn] { color: #268bd2 } /* Name.Namespace */
    c-[py] { color: #268bd2 } /* Name.Property */
    c-[ow] { color: #657b83 } /* Operator.Word */
    c-[mb] { color: #657b83 } /* Literal.Number.Bin */
    c-[mf] { color: #657b83 } /* Literal.Number.Float */
    c-[mh] { color: #657b83 } /* Literal.Number.Hex */
    c-[mi] { color: #657b83 } /* Literal.Number.Integer */
    c-[mo] { color: #657b83 } /* Literal.Number.Oct */
    c-[sa] { color: #6c71c4 } /* Literal.String.Affix */
    c-[sb] { color: #6c71c4 } /* Literal.String.Backtick */
    c-[sc] { color: #6c71c4 } /* Literal.String.Char */
    c-[dl] { color: #6c71c4 } /* Literal.String.Delimiter */
    c-[sd] { color: #6c71c4 } /* Literal.String.Doc */
    c-[se] { color: #6c71c4 } /* Literal.String.Escape */
    c-[sh] { color: #6c71c4 } /* Literal.String.Heredoc */
    c-[si] { color: #6c71c4 } /* Literal.String.Interpol */
    c-[sx] { color: #6c71c4 } /* Literal.String.Other */
    c-[sr] { color: #6c71c4 } /* Literal.String.Regex */
    c-[ss] { color: #6c71c4 } /* Literal.String.Symbol */
    c-[fm] { color: #268bd2 } /* Name.Function.Magic */
    c-[vc] { color: #cb4b16 } /* Name.Variable.Class */
    c-[vg] { color: #cb4b16 } /* Name.Variable.Global */
    c-[vi] { color: #cb4b16 } /* Name.Variable.Instance */
    c-[vm] { color: #cb4b16 } /* Name.Variable.Magic */
    c-[il] { color: #657b83 } /* Literal.Number.Integer.Long */
}
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"><a class="logo" href="https://www.w3.org/"> <img alt="W3C" height="48" src="https://www.w3.org/StyleSheets/TR/2021/logos/W3C" width="72"> </a> </p>
   <h1 class="p-name no-ref" id="title">Extensions to the PNG Third Edition Specification, Version 1.6.1</h1>
   <p id="w3c-state"><a href="https://www.w3.org/standards/types/#DNOTE">W3C Group Draft Note</a>, <time class="dt-updated" datetime="2025-09-15">15 September 2025</time></p>
   <details open>
    <summary>More details about this document</summary>
    <div data-fill-with="spec-metadata">
     <dl>
      <dt>This version:
      <dd><a class="u-url" href="https://www.w3.org/TR/2025/DNOTE-pngext-20250915/">https://www.w3.org/TR/2025/DNOTE-pngext-20250915/</a>
      <dt>Latest published version:
      <dd><a href="https://w3.org/TR/png-extensions/">https://w3.org/TR/png-extensions/</a>
      <dt>Editor's Draft:
      <dd><a href="https://w3c.github.io/PNG-spec/extensions/Overview.html">https://w3c.github.io/PNG-spec/extensions/Overview.html</a>
      <dt>History:
      <dd><a class="u-url" href="https://www.w3.org/standards/history/pngext/">https://www.w3.org/standards/history/pngext/</a>
      <dt>Feedback:
      <dd><a href="https://github.com/w3c/PNG-spec/issues/">GitHub</a>
      <dt class="editor">Editor:
      <dd class="editor p-author h-card vcard" data-editor-id="1438"><a class="p-name fn u-url url" href="https://svgees.us/">Chris Lilley</a> (<span class="p-org org">W3C</span>)
      <dt class="editor">Former Editor:
      <dd class="editor p-author h-card vcard"><span class="p-name fn">Glenn Randers-Pehrson</span>
     </dl>
    </div>
   </details>
   <div data-fill-with="warning"></div>
   <p class="copyright" data-fill-with="copyright"><a href="https://www.w3.org/policies/#copyright">Copyright</a> © 2025 <a href="https://www.w3.org/">World Wide Web Consortium</a>. <abbr title="World Wide Web Consortium">W3C</abbr><sup>®</sup> <a href="https://www.w3.org/policies/#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/policies/#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/copyright/software-license/" rel="license" title="W3C Software and Document License">permissive document license</a> rules apply. </p>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>This document is an extension to the Portable Network Graphics (PNG) specification, third edition <a data-link-type="biblio" href="#biblio-png" title="Portable Network Graphics (PNG) Specification (Third Edition)">[PNG]</a>. It describes additional public chunk types and contains additional information for use in PNG images.</p>
  </div>
  <h2 class="no-num no-toc no-ref heading settled" id="sotd"><span class="content">Status of this document</span></h2>
  <div data-fill-with="status">
   <p></p>
  </div>
  <div data-fill-with="at-risk"></div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li><a href="#intro"><span class="secno">1</span> <span class="content"> Introduction </span></a>
    <li>
     <a href="#DataRep"><span class="secno">2</span> <span class="content"> Data Representation </span></a>
     <ol class="toc">
      <li><a href="#DR.Integer-values"><span class="secno">2.1</span> <span class="content"> Integer values </span></a>
      <li><a href="#DR.Floating-point-values"><span class="secno">2.2</span> <span class="content"> Floating-point values </span></a>
     </ol>
    <li><a href="#Summary"><span class="secno">3</span> <span class="content"> Summary of Special-Purpose Chunks </span></a>
    <li>
     <a href="#Chunks"><span class="secno">4</span> <span class="content"> Chunk Descriptions </span></a>
     <ol class="toc">
      <li><a href="#C.oFFs"><span class="secno">4.1</span> <span class="content"> <span class="chunk">oFFs</span> Image offset </span></a>
      <li><a href="#C.pCAL"><span class="secno">4.2</span> <span class="content"> <span class="chunk">pCAL</span> Calibration of pixel values </span></a>
      <li><a href="#C.sCAL"><span class="secno">4.3</span> <span class="content"> <span class="chunk">sCAL</span> Physical scale of image subject </span></a>
      <li><a href="#C.gIFg"><span class="secno">4.4</span> <span class="content"> <span class="chunk">gIFg</span> GIF Graphic Control Extension </span></a>
      <li><a href="#C.gIFx"><span class="secno">4.5</span> <span class="content"> <span class="chunk">gIFx</span> GIF Application Extension </span></a>
      <li><a href="#C.sTER"><span class="secno">4.6</span> <span class="content"> <span class="chunk">sTER</span> Indicator of Stereo Image </span></a>
     </ol>
    <li>
     <a href="#RemoteChunks"><span class="secno">5</span> <span class="content"> Chunks Not Described Here </span></a>
     <ol class="toc">
      <li><a href="#R.dSIG"><span class="secno">5.1</span> <span class="content"> <span class="chunk">dSIG</span> Digital signature </span></a>
      <li><a href="#R.fRAc"><span class="secno">5.2</span> <span class="content"> <span class="chunk">fRAc</span> Fractal image parameters </span></a>
      <li><a href="#R.iDOT"><span class="secno">5.3</span> <span class="content"> <span class="chunk">iDOT</span> Apple Multithreaded Decoding </span></a>
     </ol>
    <li>
     <a href="#Keywords"><span class="secno">6</span> <span class="content"> Text Chunk Keywords </span></a>
     <ol class="toc">
      <li><a href="#K.Keywords"><span class="secno">6.1</span> <span class="content"> Additional Registered Keywords </span></a>
      <li><a href="#K.Syntax"><span class="secno">6.2</span> <span class="content"> Keyword Syntax </span></a>
     </ol>
    <li>
     <a href="#DepChunks"><span class="secno">7</span> <span class="content"> Deprecated Chunks </span></a>
     <ol class="toc">
      <li><a href="#DC.gIFt"><span class="secno">7.1</span> <span class="content"> gIFt GIF Plain Text Extension </span></a>
     </ol>
    <li><a href="#Security"><span class="secno">8</span> <span class="content"> Security Considerations </span></a>
    <li>
     <a href="#SampleCode"><span class="secno">9</span> <span class="content"> Appendix: Sample code </span></a>
     <ol class="toc">
      <li><a href="#SC.pCAL"><span class="secno">9.1</span> <span class="content"> <span class="chunk">pCAL</span> Sample code </span></a>
      <li><a href="#SC.Fixed-point-gamma-corr"><span class="secno">9.2</span> <span class="content"> Fixed-point gamma correction </span></a>
     </ol>
    <li>
     <a href="#Rationale"><span class="secno">10</span> <span class="content"> Rationale </span></a>
     <ol class="toc">
      <li>
       <a href="#R.pCAL"><span class="secno">10.1</span> <span class="content"> pCAL Rationale </span></a>
       <ol class="toc">
        <li><a href="#pCAL.red"><span class="secno">10.1.1</span> <span class="content"> Redundant equation types </span></a>
        <li><a href="#pCAL.x0x1"><span class="secno">10.1.2</span> <span class="content"> What are <code>x0</code> and <code>x1</code> for? </span></a>
        <li><a href="#pCAL.division"><span class="secno">10.1.3</span> <span class="content"> Integer division </span></a>
       </ol>
     </ol>
    <li><a href="#History"><span class="secno">11</span> <span class="content"> Appendix: Revision History </span></a>
    <li>
     <a href="#Credits"><span class="secno">12</span> <span class="content"> Credits </span></a>
     <ol class="toc">
      <li><a href="#Credits.editors"><span class="secno">12.1</span> <span class="content"> Editors </span></a>
      <li><a href="#Credits.contrib"><span class="secno">12.2</span> <span class="content"> Contributors </span></a>
      <li><a href="#Credits.marks"><span class="secno">12.3</span> <span class="content"> Trademarks </span></a>
     </ol>
    <li>
     <a href="#w3c-conformance"><span class="secno"></span> <span class="content">Conformance</span></a>
     <ol class="toc">
      <li><a href="#w3c-conventions"><span class="secno"></span> <span class="content">Document conventions</span></a>
     </ol>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#normative"><span class="secno"></span> <span class="content">Normative References</span></a>
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content"> Introduction </span><a class="self-link" href="#intro"></a></h2>
   <p>This document,
    together with the PNG specification <a data-link-type="biblio" href="#biblio-png" title="Portable Network Graphics (PNG) Specification (Third Edition)">[PNG]</a>,
    contains the entire list of registered "public" PNG chunks.
    The additional registered chunks appearing in this document are the <span class="chunk">oFFs</span>, <span class="chunk">pCAL</span>, <span class="chunk">sCAL</span>, <span class="chunk">gIFg</span>, <span class="chunk">gIFx</span>, <span class="chunk">sTER</span>, and <span class="chunk">fRAc</span> chunks,
    plus the deprecated <span class="chunk">gIFt</span> chunk.</p>
   <p>Additional chunk types may be proposed
    for inclusion in this list
    by contacting the PNG specification maintainers at
    public-png@w3.org
    or by raising an issue on their <a href="https://github.com/w3c/PNG-spec/issues/">GitHub repository</a> (preferred).
    Attention is drawn to the <a href="https://www.w3.org/TR/PNG/#B-NewChunksAppendix">Guidelines for new chunk types</a>.</p>
   <p>Chunks described here
    are expected to be less widely supported
    than those defined in the basic specification.
    However,
    application authors are encouraged
    to use these chunk types
    whenever appropriate
    for their applications.</p>
   <p>This document
    also describes data representations
    that do not occur in the core PNG format,
    but are used in one or more special-purpose chunks.
    New chunks should use these representations
    whenever applicable,
    in order to maximize portability
    and simplify decoders.</p>
   <h2 class="heading settled" data-level="2" id="DataRep"><span class="secno">2. </span><span class="content"> Data Representation </span><a class="self-link" href="#DataRep"></a></h2>
   <h3 class="heading settled" data-level="2.1" id="DR.Integer-values"><span class="secno">2.1. </span><span class="content"> Integer values </span><a class="self-link" href="#DR.Integer-values"></a></h3>
   <p>Refer to <a href="https://w3c.github.io/PNG-spec/#7Integers-and-byte-order">Section 7.1
    of the PNG specification</a> <a data-link-type="biblio" href="#biblio-png" title="Portable Network Graphics (PNG) Specification (Third Edition)">[PNG]</a> for the format and
    range of integer values</p>
   <h3 class="heading settled" data-level="2.2" id="DR.Floating-point-values"><span class="secno">2.2. </span><span class="content"> Floating-point values </span><a class="self-link" href="#DR.Floating-point-values"></a></h3>
   <p>The core of PNG
    does not use floating-point numbers anywhere;
    it uses integers
    or, where applicable,
    fixed-point fractional values.
    However, special-purpose chunks
    may need to represent values
    that do not fit comfortably in fixed-point notation.
    The textual floating-point notation
    defined here
    is recommended for use in all such cases.
    This representation is simple,
    has no a priori limits on range or precision,
    and is portable across all machines.</p>
   <p>A floating-point value
    in this notation
    is represented by an ASCII text string
    in a standardized decimal floating-point format.
    The string is variable-length
    and must be terminated by a null (zero) character
    unless it is the last item in its chunk.
    The string consists of
    an optional sign ("+" or "-"),
    an integer part,
    a fraction part beginning with a decimal point ("."),
    and an exponent part beginning with an "E" or "e"
    and optional sign.
    The integer, fraction, and exponent parts
    each contain one or more digits (ASCII "0" to "9").
    Either the integer part or the fraction part,
    but not both,
    may be omitted.
    A decimal point is allowed,
    but not required,
    if there is no fraction part.
    The exponent part may be omitted.
    No spaces
    or any other character besides those specified
    may appear.</p>
   <p class="note" role="note"><span class="marker">Note:</span> in particular, C-language "F" and "L" suffixes
    are not allowed,
    the string "." is not allowed as a shorthand for 0
    as in some other programming languages,
    and no commas or underscores are allowed.
    This format ought to be easily readable
    in all programming environments.</p>
   <h2 class="heading settled" data-level="3" id="Summary"><span class="secno">3. </span><span class="content"> Summary of Special-Purpose Chunks </span><a class="self-link" href="#Summary"></a></h2>
   <p>This table summarizes some properties of the chunks described in this document.
    For standard chunks, see the PNG specification <a data-link-type="biblio" href="#biblio-png" title="Portable Network Graphics (PNG) Specification (Third Edition)">[PNG]</a>.</p>
   <table>
    <tbody>
     <tr>
      <th>Name   
      <th>Multiple OK?
      <th>Ordering constraints
     <tr>
      <td><a href="#C.oFFs"><span class="chunk">oFFs</span></a>
      <td>No
      <td>Before IDAT
     <tr>
      <td><a href="#C.pCAL"><span class="chunk">pCAL</span></a>
      <td>No
      <td>Before IDAT
     <tr>
      <td><a href="#C.sCAL"><span class="chunk">sCAL</span></a>
      <td>No
      <td>Before IDAT
     <tr>
      <td><a href="#C.gIFg"><span class="chunk">gIFg</span></a>
      <td>Yes
      <td>None
     <tr>
      <td><a href="#DC.gIFt"><span class="chunk">gIFt</span></a>
      <td>Yes
      <td>None <em>(this chunk is deprecated)</em>
     <tr>
      <td><a href="#C.gIFx"><span class="chunk">gIFx</span></a>
      <td>Yes
      <td>None
     <tr>
      <td><a href="#C.sTER"><span class="chunk">sTER</span></a>
      <td>No
      <td>Before IDAT
     <tr>
      <td><a href="R.dSIG"><span class="chunk">dSIG</span></a>
      <td>Yes
      <td>In pairs, immediately after IHDR and before IEND
     <tr>
      <td><a href="R.fRAc"><span class="chunk">fRAc</span></a>
      <td>Yes
      <td>None
   </table>
   <h2 class="heading settled" data-level="4" id="Chunks"><span class="secno">4. </span><span class="content"> Chunk Descriptions </span><a class="self-link" href="#Chunks"></a></h2>
   <h3 class="heading settled" data-level="4.1" id="C.oFFs"><span class="secno">4.1. </span><span class="content"> <span class="chunk">oFFs</span> Image offset </span><a class="self-link" href="#C.oFFs"></a></h3>
   <p>The <span class="chunk">oFFs</span> chunk
    gives the position on a printed page
    at which the image should be output
    when printed alone.
    It can also be used
    to define the image’s location
    with respect to a larger screen
    or other application-specific coordinate system.</p>
   <p>The <span class="chunk">oFFs</span> chunk contains:</p>
   <table>
    <tbody>
     <tr>
      <th>X position:
      <td>4 bytes (signed integer)
     <tr>
      <th>Y position:
      <td>4 bytes (signed integer)
     <tr>
      <th>Unit specifier:
      <td>1 byte
   </table>
   <p>Both position values are signed. The following values are legal for the unit specifier:</p>
   <table>
    <tbody>
     <tr>
      <th>0:
      <td>unit is the pixel (true dimensions unspecified)
     <tr>
      <th>1:
      <td>unit is the micrometer
   </table>
   <p class="note" role="note"><span class="marker">Note:</span> for conversions,
    one inch is equal to exactly 25400 micrometers.
    A micrometer (also called a micron)
    is 10<sup>-6</sup> meter.</p>
   <p>The X position is measured rightwards
    from the left edge of the page to the left edge of the image;
    the Y position is measured downwards
    from the top edge of the page to the top edge of the image.
    Note that negative values are permitted,
    and denote displacement in the opposite directions.
    Although oFFs can specify
    an image placement that is partially or wholly outside the page boundaries,
    the result of such placement is application-dependent.</p>
   <p>If present, this chunk must precede the first <span class="chunk">IDAT</span> chunk.</p>
   <h3 class="heading settled" data-level="4.2" id="C.pCAL"><span class="secno">4.2. </span><span class="content"> <span class="chunk">pCAL</span> Calibration of pixel values </span><a class="self-link" href="#C.pCAL"></a></h3>
   <p>When a PNG file is being used
to store physical data other than color values,
such as a two-dimensional temperature field,
the <span class="chunk">pCAL</span> chunk can be used
to record the relationship (mapping)
between stored pixel samples,
original samples,
and actual physical values.
The <span class="chunk">pCAL</span> data might be used
to construct a reference color bar beside the image,
or to extract the original physical data values from the file.
It is not expected to affect the way the pixels are displayed.
Another method should be used
if the encoder wants the decoder to modify the sample values for display purposes.</p>
   <p>The <span class="chunk">pCAL</span> chunk contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Calibration name: 
      <td>1-79 bytes (character string) 
     <tr>
      <th>Null separator: 
      <td>1 byte 
     <tr>
      <th>Original zero (x0): 
      <td>4 bytes (signed integer) 
     <tr>
      <th>Original max  (x1): 
      <td>4 bytes (signed integer) 
     <tr>
      <th>Equation type: 
      <td>1 byte 
     <tr>
      <th>Number of parameters: 
      <td>1 byte 
     <tr>
      <th>Unit name: 
      <td>0 or more bytes (character string) 
     <tr>
      <th>Null separator: 
      <td>1 byte 
     <tr>
      <th>Parameter 0 (p0): 
      <td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>) 
     <tr>
      <th>Null separator: 
      <td>1 byte 
     <tr>
      <th>Parameter 1 (p1): 
      <td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>) 
     <tr>
      <td colspan="2">...etc...
   </table>
   <p>There is no null separator
    after the final parameter
    (or after the unit name,
    if there are zero parameters).
    The number of parameters field
    must agree with
    the actual number of parameters present in the chunk,
    and must be correct for the specified equation type (see below).</p>
   <p>The calibration name
    can be any convenient name for referring to the mapping,
    and is subject to the same restrictions as
    the keyword in a PNG text chunk:
    it must contain only printable Latin-1 [ISO/IEC-8859-1] characters
    (decimal codes 33-126 and 161-255)
    and spaces (decimal code 32),
    but no leading, trailing, or consecutive spaces.</p>
   <p>The calibration name
    can permit applications or people
    to choose the appropriate pCAL chunk
    when more than one is present
    (this could occur in a multi-image PNG file, but not in a static PNG file).
    For example, a calibration name of "SI" or "English"
    could be used to identify the system of units in the pCAL chunk
    as well as in other chunk types,
    to permit a decoder
    to select an appropriate set of chunks based on their names.</p>
   <p>The <span class="chunk">pCAL</span> chunk defines two mappings:</p>
   <ul>
    <li data-md>
     <p>A mapping from the stored samples,
which are unsigned integers in the range 0..max,
where max=2<sup>bitdepth</sup>-1,
to the original samples,
which are signed integers.
The x0 and x1 fields,
 together with the bit depth for the image,
 define this mapping.</p>
    <li data-md>
     <p>A mapping from the original samples
to the physical values,
which are usually real numbers with units.
This mapping is defined by x0, x1,
the equation type, parameters, and unit name.</p>
   </ul>
   <p>The mapping between the stored samples
    and the original samples
    is given by the following equations:</p>
<pre class="lang-C highlight"><c- n>original_sample</c-> <c- o>=</c->
    <c- p>(</c-><c- n>stored_sample</c-> <c- o>*</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>)</c-> <c- o>+</c-> <c- n>max</c-><c- o>/</c-><c- mi>2</c-><c- p>)</c-> <c- o>/</c-> <c- n>max</c-> <c- o>+</c-> <c- n>x0</c->

<c- n>stored_sample</c-> <c- o>=</c->
     <c- p>((</c-><c- n>original_sample</c-> <c- o>-</c-> <c- n>x0</c-><c- p>)</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>)</c-><c- o>/</c-><c- mi>2</c-><c- p>)</c-> <c- o>/</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>)</c->
     <c- n>clipped</c-> <c- n>to</c-> <c- n>the</c-> <c- n>range</c-> <c- mf>0.</c-><c- p>.</c-><c- n>max</c->
</pre>
   <p>In these equations,
    "/" means integer division that rounds toward negative infinity,
    so <code>n/d = integer(floor(real(a)/real(b))))</code>.
    Note that this is the same as
    the "/" operator in the C programming language
    when n and d are nonnegative,
    but not necessarily when n or d is negative.</p>
   <p>Notice that x0 and x1 are the original samples
    that correspond to the stored samples 0 and max, respectively.
    Encoders will usually set x0=0 and x1=max to indicate
    that the stored samples are equal to the original samples.
    Note that x0 is not constrained to be less than x1,
    and neither is constrained to be positive,
    but they must be different from each other.</p>
   <p>This mapping is lossless and reversible
    when <code>abs(x1-x0) &lt;= max</code> and the original sample is in the range <code>x0..x1</code>.
    If <code>abs(x1-x0) > max</code> then there can be no lossless reversible mapping,
    but the functions provide the best integer approximations
    to floating-point affine transformations.</p>
   <p>The mapping between the original samples and the physical values
    is given by one of several equations,
    depending on the equation type,
    which may have the following values:</p>
   <table>
    <tbody>
     <tr>
      <th>0:
      <td>Linear mapping
     <tr>
      <th>1:
      <td>Base-e exponential mapping
     <tr>
      <th>2:
      <td>Arbitrary-base exponential mapping
     <tr>
      <th>3:
      <td>Hyperbolic mapping
   </table>
   <p>For equation type 0:</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c-> <c- n>p0</c-> <c- o>+</c-> <c- n>p1</c-> <c- o>*</c-> <c- n>original_sample</c-> <c- o>/</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>)</c->
</pre>
   <p>For equation type 1:</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c->
   <c- n>p0</c-> <c- o>+</c-> <c- n>p1</c-> <c- o>*</c-> <c- n>exp</c-><c- p>(</c-><c- n>p2</c-> <c- o>*</c-> <c- n>original_sample</c-> <c- o>/</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>))</c->
</pre>
   <p>For equation type 2:</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c->
   <c- n>p0</c-> <c- o>+</c-> <c- n>p1</c-> <c- o>*</c-> <c- n>pow</c-><c- p>(</c-><c- n>p2</c-><c- p>,</c-> <c- p>(</c-><c- n>original_sample</c-> <c- o>/</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>)))</c->
</pre>
   <p>For equation type 3:</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c->
   <c- n>p0</c-> <c- o>+</c-> <c- n>p1</c-> <c- o>*</c-> <c- n>sinh</c-><c- p>(</c-><c- n>p2</c-> <c- o>*</c-> <c- p>(</c-><c- n>original_sample</c-> <c- o>-</c-> <c- n>p3</c-><c- p>)</c-> <c- o>/</c-> <c- p>(</c-><c- n>x1</c-><c- o>-</c-><c- n>x0</c-><c- p>))</c->
</pre>
   <p>For these physical value equations, "/" means floating-point division.</p>
   <p>The function <code>exp(x)</code> is <code>e</code> raised to the power of <code>x</code>,
    where <code>e</code> is the base of the natural logarithms,
    approximately 2.71828182846.
    The exponential function <code>exp()</code> is the inverse the natural logarithm function <code>ln()</code>.</p>
   <p>The function <code>pow(x,y)</code> is <code>x</code> raised to the power of <code>y</code>.</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c-><c- n>pow</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-><c- n>y</c-><c- p>)</c-> <c- o>=</c-> <c- n>exp</c-><c- p>(</c-><c- n>y</c-> <c- o>*</c-> <c- n>ln</c-><c- p>(</c-><c- n>x</c-><c- p>))</c->
</pre>
   <p>The function <code>sinh(x)</code> is
    the hyperbolic sine of <code>x</code>.</p>
<pre class="lang-C highlight"><c- n>physical_value</c-> <c- o>=</c->
    <c- n>sinh</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>=</c-> <c- mf>0.5</c-> <c- o>*</c-> <c- p>(</c-><c- n>exp</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>-</c-> <c- n>exp</c-><c- p>(</c-><c- o>-</c-><c- n>x</c-><c- p>))</c->
</pre>
   <p>The units for the physical values
    are given by the unit name,
    which may contain any number of printable Latin-1 characters,
    with no limitation on the number and position of blanks.</p>
   <div class="example" id="example-a49cc7eb"><a class="self-link" href="#example-a49cc7eb"></a> For example, "K", "population density", "MPa".
        A zero-length string can be used for dimensionless data. </div>
   <p>For color types 0 (gray) and 4 (gray-alpha),
    the mappings apply to the gray sample values
    (but not to the alpha sample).
    For color types 2 (RGB), 3 (indexed RGB), and 6 (RGBA),
    the mappings apply independently
    to each of the red, green, and blue sample values
    (but not the alpha sample).
    In the case of color type 3 (indexed RGB),
    the mapping refers to the RGB samples
    and not to the index values.</p>
   <p>Linear data can be expressed with equation type 0.</p>
   <p>Pure logarithmic data can be expressed
    with either equation type 1 or 2:</p>
   <table>
    <tbody>
     <tr>
      <th>Equation type 1
      <th>Equation type 2
     <tr>
      <td>x0 = 0 
      <td>x0 = 0
     <tr>
      <td>x1 = max
      <td>x1 = max
     <tr>
      <td>p0 = 0
      <td>p0 = 0
     <tr>
      <td>p1 = bottom
      <td>p1 = bottom
     <tr>
      <td>p2 = ln(top/bottom)
      <td>p2 = top/bottom
   </table>
   <p>Equation types 1 and 2 are functionally equivalent;
    both are defined because authors may find
    one or the other more convenient.</p>
   <p>Using equation type 3,
    floating-point data can be reduced (with loss)
    to a set of integer samples
    such that the resolution of the stored data
    is roughly proportional to its magnitude.</p>
   <div class="example" id="example-e3c29ac5">
    <a class="self-link" href="#example-e3c29ac5"></a> For example,
        floating-point data ranging from
        -10<sup>31</sup> to 10<sup>31</sup> (the usual range of 32-bit floating-point numbers)
        can be represented with: 
<pre>Equation type 3
x0 = 0
x1 = 65535
p0 = 0.0
p1 = 1.0e-30
p2 = 280.0
p3 = 32767.0
</pre>
   </div>
   <p>The resolution near zero is about 10<sup>-33</sup>,
    while the resolution near 10<sup>31</sup> or -10<sup>31</sup> is about 10<sup>28</sup>.
    Everywhere, the resolution is about 0.4 percent of the magnitude.</p>
   <div class="note" role="note">
     Note: those floating-point parameters
        could be stored in the chunk more compactly
        as follows: 
<pre>p0 = 0
p1 = 1e-30
p2 = 280
p3 = 32767
</pre>
   </div>
   <p>Applications should use double precision arithmetic
    (or take other precautions)
    while performing the mappings for equation types 1, 2, and 3,
    to prevent overflow of intermediate results
    when <code>p1</code> is small
    and the <code>exp()</code>, <code>pow()</code>, or <code>sinh()</code> function is large.</p>
   <p>If present,
    the <span class="chunk">pCAL</span> chunk must appear
    before the first <span class="chunk">IDAT</span> chunk.
    Only one instance of the <span class="chunk">pCAL</span> chunk
    is permitted in a PNG datastream.</p>
   <h3 class="heading settled" data-level="4.3" id="C.sCAL"><span class="secno">4.3. </span><span class="content"> <span class="chunk">sCAL</span> Physical scale of image subject </span><a class="self-link" href="#C.sCAL"></a></h3>
   <p>While the <span class="chunk">pHYs</span> chunk
    is used to record the physical size of the image itself
    as it was scanned
    or as it should be printed,
    certain images
    (such as maps, photomicrographs, astronomical surveys, floor plans, and others)
    may benefit from knowing the actual physical dimensions of the image’s subject
    for remote measurement and other purposes.
    The <span class="chunk">sCAL</span> chunk serves this need. It contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Unit specifier:
      <td>1 byte
     <tr>
      <th>Pixel width:
      <td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>)
     <tr>
      <th>Null separator:
      <td>1 byte
     <tr>
      <th>Pixel height:
      <td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>)
   </table>
   <p>The following values are legal for the unit specifier:</p>
   <table>
    <tbody>
     <tr>
      <th>1:
      <td>unit is the meter
     <tr>
      <th>2:
      <td>unit is the radian
   </table>
   <p>Following the unit specifier are two ASCII strings.
    The first string defines the physical width represented by one image pixel;
    the second string defines the physical height represented by one pixel.
    The two strings are separated by a zero byte (null character).
    As in the text chunks, there is no trailing zero byte for the final string.
    Each of these strings contains a floating-point constant
    in the format specified above
    (<a href="#DR.Floating-point-values">Floating-point values, Section 2.2</a>).
    Both values are required to be greater than zero.</p>
   <p>If present, this chunk must precede
    the first <span class="chunk">IDAT</span> chunk.</p>
   <h3 class="heading settled" data-level="4.4" id="C.gIFg"><span class="secno">4.4. </span><span class="content"> <span class="chunk">gIFg</span> GIF Graphic Control Extension </span><a class="self-link" href="#C.gIFg"></a></h3>
   <p>The <span class="chunk">gIFg</span> chunk is provided
    for backward compatibility with the GIF89a Graphic Control Extension <a data-link-type="biblio" href="#biblio-gif" title="Graphics Interchange Format">[GIF]</a>.
    It contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Disposal Method:
      <td>1 byte
     <tr>
      <th>User Input Flag:
      <td>1 byte
     <tr>
      <th>Delay Time:
      <td>2 bytes (byte order converted from GIF)
   </table>
   <p>The Disposal Method indicates
    the way in which the graphic is to be treated
    after being displayed.
    The User Input Flag indicates
    whether user input is required before continuing.
    The Delay Time specifies
    the number of hundredths (1/100) of a second to delay
    before continuing with the processing of the datastream.
    Note that this field is to be byte-order-converted.</p>
   <p>The "Transparent Color Flag" and "Transparent Color Index" fields
    found in the GIF89a Graphic Control Extension
    are omitted from <span class="chunk">gIFg</span>.
    These fields should be converted using the transparency features of basic PNG.</p>
   <p>The GIF specification allows
    at most one Graphic Control Extension
    to preceed each graphic rendering block.
    Because a static PNG file holds only one image,
    it is expected that <span class="chunk">gIFg</span> will appear at most once, before <span class="chunk">IDAT</span>,
    but there is no strict requirement.</p>
   <p class="note" role="note"><span class="marker">Note:</span> this chunk is provided solely to improve round-tripping
    when converting from animated GIF to static PNG.
    It has no effect on rendering of the PNG image.
    Including this chunk does not make the PNG animated.</p>
   <h3 class="heading settled" data-level="4.5" id="C.gIFx"><span class="secno">4.5. </span><span class="content"> <span class="chunk">gIFx</span> GIF Application Extension </span><a class="self-link" href="#C.gIFx"></a></h3>
   <p>The <span class="chunk">gIFx</span> chunk is provided
    for backward compatibility with the GIF89a Application Extension <a data-link-type="biblio" href="#biblio-gif" title="Graphics Interchange Format">[GIF]</a>.
    The Application Extension contains application-specific information.
    This chunk contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Application Identifier:
      <td>8 bytes
     <tr>
      <th>Authentication Code:
      <td>3 bytes
     <tr>
      <th>Application Data:
      <td><em>n</em> bytes
   </table>
   <p>The Application Identifier is a sequence of eight printable ASCII characters
    used to identify the application creating the Application Extension.
    The Authentication Code is three additional bytes
    that the application may use to further validate the Application Extension.
    The remainder of the chunk is application-specific data
    whose content is not defined by the GIF specification.</p>
   <p>Note that GIF-to-PNG converters
    should not attempt to perform byte reordering
    on the contents of the Application Extension.
    The data is simply transcribed without any processing
    except for de-blocking GIF sub-blocks.</p>
   <p>Applications that formerly used GIF Application Extensions
    may define special-purpose PNG chunks
    to replace their application extensions.
    If a GIF-to-PNG converter recognizes the Application Identifier
    and is aware of a corresponding PNG chunk,
    it may choose to convert the Application Extension into that PNG chunk type
    rather than using <span class="chunk">gIFx</span>.</p>
   <h3 class="heading settled" data-level="4.6" id="C.sTER"><span class="secno">4.6. </span><span class="content"> <span class="chunk">sTER</span> Indicator of Stereo Image </span><a class="self-link" href="#C.sTER"></a></h3>
   <p>When present, the <span class="chunk">sTER</span> chunk
    indicates that the datastream contains a stereo pair of subimages
    within a single PNG image.</p>
   <p>The <span class="chunk">sTER</span> chunk contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Mode:
      <td>1 byte
   </table>
   <p>The following values are legal for the mode specifier:</p>
   <table>
    <tbody>
     <tr>
      <th>0:
      <td>cross-fuse layout
     <tr>
      <th>1:
      <td>diverging-fuse layout
   </table>
   <p>The <span class="chunk">sTER</span> chunk
    with <code>mode==0</code> or <code>mode==1</code> indicates that the datastream contains two subimages,
    encoded within a single PNG image.
    They are arranged side-by-side,
    with one subimage intended for presentation to the right eye
    and the other subimage intended for presentation to the left eye.</p>
   <p>The left edge of the right subimage
    must be on a column that is evenly divisible by eight,
    so that if interlacing is employed
    the two images will have coordinated interlacing.
    Padding columns between the two subimages
    must be introduced by the encoder if necessary.
    The <span class="chunk">sTER</span> chunk
    imposes no requirements on the contents of the padding pixels.
    For compatibility with software not supporting <span class="chunk">sTER</span>,
    it does not exempt the padding pixels from existing requirements;
    for example, in palette images,
    the padding pixels must be valid palette indices.
    The two subimages must have the same dimensions
    after removal of any padding.</p>
   <p>When <code>mode==0</code>,
    the right-eye image appears at the left
    and the left-eye image appears at the right,
    suitable for cross-eyed free viewing.
    When <code>mode==1</code>,
    the left-eye image appears at the left
    and the right-eye image appears at the right,
    suitable for divergent (wall-eyed) free viewing.</p>
   <p>Decoders that are aware of the <span class="chunk">sTER</span> chunk
    may display the two images in any suitable manner,
    with or without the padding.
    Decoders that are not aware of the <span class="chunk">sTER</span> chunk,
    and those that recognize the chunk
    but choose not to treat stereo pairs differently from regular PNG images,
    will naturally display them side-by-side in a manner
    suitable for free viewing.</p>
   <p>If present, the <span class="chunk">sTER</span> chunk
    must appear before the first <span class="chunk">IDAT</span> chunk.</p>
   <p>Given two subimages with width <code>subimage_width</code>,
    encoders can calculate the inter-subimage <code>padding</code> and total width <code>W</code> using the following pseudocode:</p>
<pre class="lang-pascal highlight"><c- n>padding</c->  <c- o>:=</c-> <c- mi>7</c-> <c- o>-</c-> <c- p>((</c-><c- n>subimage_width</c-> <c- o>-</c-> <c- mi>1</c-><c- p>)</c-> <c- k>mod</c-> <c- mi>8</c-><c- p>)</c->
<c- n>W</c->        <c- o>:=</c-> <c- mi>2</c-> <c- o>*</c-> <c- n>subimage_width</c-> <c- o>+</c-> <c- n>padding</c->
</pre>
   <p>Given an image with width <code>W</code>,
    decoders can calculate the <code>subimage_width</code> and inter-subimage <code>padding</code> using the following pseudocode:</p>
<pre class="lang-pascal highlight"><c- n>padding</c-> <c- o>:=</c-> <c- mi>15</c-> <c- o>-</c-> <c- p>((</c-><c- n>W</c-> <c- o>-</c-> <c- mi>1</c-><c- p>)</c-> <c- k>mod</c-> <c- mi>16</c-><c- p>)</c->
<c- k>if</c-> <c- p>(</c-><c- n>padding</c-> <c- o>></c-> <c- mi>7</c-><c- p>)</c-> <c- k>then</c-> <c- n>error</c->
<c- n>subimage_width</c-> <c- o>:=</c-> <c- p>(</c-><c- n>W</c-> <c- o>-</c-> <c- n>padding</c-><c- p>)</c-> <c- o>/</c-> <c- mi>2</c->
</pre>
   <p>Decoders can assume that the samples
    in the left and right subimages
    are cosited,
    such that the subimages and their centers
    are coincident at the projection plane.
    Decoders can also assume that the left and right subimages
    are intended to be presented directly
    to the right and left eyes of the user/viewer
    without independent scaling,
    rotation
    or displacement.
    I.e., the subimages will be presented at the same size
    in the same relative position and orientation
    to each eye of the viewer.</p>
   <p>Encoders should use the <span class="chunk">pHYs</span> chunk
    to indicate the pixel’s size ratio
    when it is not 1:1.</p>
   <p>It is recommended that encoders use
    the cross-fusing layout (mode==0),
    especially when the image centers are separated
    by more than 65 millimeters
    when displayed on a typical monitor.</p>
   <h2 class="heading settled" data-level="5" id="RemoteChunks"><span class="secno">5. </span><span class="content"> Chunks Not Described Here </span><a class="self-link" href="#RemoteChunks"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="R.dSIG"><span class="secno">5.1. </span><span class="content"> <span class="chunk">dSIG</span> Digital signature </span><a class="self-link" href="#R.dSIG"></a></h3>
   <p>The <span class="chunk">dSIG</span> chunk
    provides a digital signature
    that guarantees that the contents
    of the portion of the entire datastream
    enclosed in a pair of such chunks
    has not changed
    since the digital signature was added.</p>
   <p>This chunk is described in detail
    in a separate document, <a data-link-type="biblio" href="#biblio-dsig-spec" title="PNG Digital Signatures: Extension Specification">[dSIG-spec]</a>,
    which is accompanied by an example
    provided in <a data-link-type="biblio" href="#biblio-dsig-example" title="PNG Digital Signatures: Commented Example">[dSIG-example]</a>.</p>
   <h3 class="heading settled" data-level="5.2" id="R.fRAc"><span class="secno">5.2. </span><span class="content"> <span class="chunk">fRAc</span> Fractal image parameters </span><a class="self-link" href="#R.fRAc"></a></h3>
   <p>The <span class="chunk">fRAc</span> chunk
    was intended to describe
    the parameters used to generate a fractal image.
    The specification
    for the contents of the <span class="chunk">fRAc</span> chunk
    was being developed by Tim Wegner, twegner @ phoenix.net.</p>
   <p>In the future, chunks will be fully specified
    before they are registered.</p>
   <h3 class="heading settled" data-level="5.3" id="R.iDOT"><span class="secno">5.3. </span><span class="content"> <span class="chunk">iDOT</span> Apple Multithreaded Decoding </span><a class="self-link" href="#R.iDOT"></a></h3>
   <p>The <span class="chunk">iDOT</span> chunk enables multi-core machines
    to use (at least) two cores to decode the PNG datastream.</p>
   <p>It was developed by Apple, around 2011, but never registered.
    It is commonly found in PNG images generated on Apple hardware.</p>
   <p>This chunk has been reverse-engineered, and is described in detail
    in a separate document, <a data-link-type="biblio" href="#biblio-idot-description" title="Connecting the iDOTs">[iDOT-description]</a>.</p>
   <h2 class="heading settled" data-level="6" id="Keywords"><span class="secno">6. </span><span class="content"> Text Chunk Keywords </span><a class="self-link" href="#Keywords"></a></h2>
   <h3 class="heading settled" data-level="6.1" id="K.Keywords"><span class="secno">6.1. </span><span class="content"> Additional Registered Keywords </span><a class="self-link" href="#K.Keywords"></a></h3>
   <p>(none)</p>
   <h3 class="heading settled" data-level="6.2" id="K.Syntax"><span class="secno">6.2. </span><span class="content"> Keyword Syntax </span><a class="self-link" href="#K.Syntax"></a></h3>
   <p>All registered textual keywords
    in text chunks
    and all other chunk types
    are limited to the ASCII characters A-Z, a-z, 0-9, space,
    and the following 20 symbols:</p>
<pre>! " % &amp; ' ( ) * + , - . / : ; &lt; = > ? _
</pre>
   <p>but not the remaining 12 symbols:</p>
<pre># $ @ [ \ ] ^ ` { | } ~
</pre>
   <p>This restricted set
    is the ISO-646 "invariant" character set <a data-link-type="biblio" href="#biblio-iso646" title="Information technology — ISO 7-bit coded character set for information interchange">[ISO646]</a>.
    These characters have the same numeric codes
    in all ISO character sets,
    including all national variants of ASCII.</p>
   <h2 class="heading settled" data-level="7" id="DepChunks"><span class="secno">7. </span><span class="content"> Deprecated Chunks </span><a class="self-link" href="#DepChunks"></a></h2>
   <p>The chunks listed in this section are registered, but deprecated. Encoders are <em>discouraged</em> from using them, and decoders are not encouraged to support them.</p>
   <h3 class="heading settled" data-level="7.1" id="DC.gIFt"><span class="secno">7.1. </span><span class="content"> gIFt GIF Plain Text Extension </span><a class="self-link" href="#DC.gIFt"></a></h3>
   <p>The <span class="chunk">gIFt</span> chunk
    was originally provided for backward compatibility
    with the GIF89a Plain Text Extension <a data-link-type="biblio" href="#biblio-gif" title="Graphics Interchange Format">[GIF]</a>,
    but <span class="chunk">gIFt</span> is now deprecated
    because it suffers from some fundamental design flaws.</p>
   <ul>
    <li data-md>
     <p>GIF considers a Plain Text Extension
to be a Graphic Rendering Block,
just like an image,
so a GIF datastream
containing an image
and a Plain Text Extension
is really a multi-image datastream
with ordering issues
(like associating each Graphic Control Extension
with the proper Graphic Rendering Block).
PNG, being a single-image format
with no provisions for handling these ordering issues,
is not equipped to contain both <span class="chunk">IDAT</span> and <span class="chunk">gIFt</span> simultaneously.
Since <span class="chunk">IDAT</span> is required, <span class="chunk">gIFt</span> must be discouraged.</p>
    <li data-md>
     <p>The Text Foreground Color and Text Background Color fields
of the Plain Text Extension
are converted to RGB,
rather than being converted to RGBA
or left as palette indexes.
Therefore, transparency information can be lost.</p>
   </ul>
   <p>The <span class="chunk">gIFt</span> chunk contains:</p>
   <table>
    <tbody>
     <tr>
      <th>Text Grid Left Position:
      <td>4 bytes (signed integer, byte order and size converted)
     <tr>
      <th>Text Grid Top Position:
      <td>4 bytes (signed integer, byte order and size converted)
     <tr>
      <th>Text Grid Width:
      <td>4 bytes (unsigned integer, byte order and size converted)
     <tr>
      <th>Text Grid Height:
      <td>4 bytes (unsigned integer, byte order and size converted)
     <tr>
      <th>Character Cell Width:
      <td>1 byte
     <tr>
      <th>Character Cell Height:
      <td>1 byte
     <tr>
      <th>Text Foreground Color:
      <td>3 bytes (R,G,B samples)
     <tr>
      <th>Text Background Color:
      <td>3 bytes (R,G,B samples)
     <tr>
      <th>Plain Text Data:
      <td><em>n</em> bytes
   </table>
   <p>Text Grid Left Position,
    Top Position,
    Width,
    and Height
    specify the text area position
    and size in pixels.
    The converter must reformat these fields
    from 2-byte LSB-first unsigned integers
    to 4-byte MSB-first signed or unsigned integers.</p>
   <p class="note" role="note"><span class="marker">Note:</span> GIF defines the position
    to be relative to the upper left corner
    of the logical screen.
    If an <span class="chunk">oFFs</span> chunk is also present,
    a decoder should assume that the oFFs chunk
    defines the offset of the image
    relative to the GIF logical screen;
    hence subtracting the oFFs values
    (converted from micrometers to pixels if necessary)
    from the Text Grid Left and Top Positions
    gives the text area position
    relative to the main PNG image.</p>
   <p>Character Cell Width and Height
    give the dimensions of each character in pixels.</p>
   <p>Text Foreground
    and Background Color
    give the colors to be used
    to render text foreground and background.</p>
   <p class="note" role="note"><span class="marker">Note:</span> the GIF-to-PNG converter
    must replace the palette index values
    found in the GIF Plain Text Extension block
    with the corresponding palette entry.</p>
   <p>The remainder of the chunk is the text to be displayed.</p>
   <p class="note" role="note"><span class="marker">Note:</span> this data is not in GIF sub-block format,
    but is a continuous datastream.</p>
   <h2 class="heading settled" data-level="8" id="Security"><span class="secno">8. </span><span class="content"> Security Considerations </span><a class="self-link" href="#Security"></a></h2>
   <p>The normal precautions
    (see the <a href="https://w3c.github.io/PNG-spec/#13Security-considerations">Security
    considerations section</a> of the PNG specification)
    should be taken when displaying text
    contained in the <span class="chunk">sCAL</span> calibration name, <span class="chunk">pCAL</span> unit name,
    or any <a href="DR.Floating-point-values">ASCII floating-point fields</a>.</p>
   <p>Applications must take care
    to avoid underflow and overflow
    of intermediate results
    when converting data from one form to another
    according to the <span class="chunk">pCAL</span> mappings.</p>
   <h2 class="heading settled" data-level="9" id="SampleCode"><span class="secno">9. </span><span class="content"> Appendix: Sample code </span><a class="self-link" href="#SampleCode"></a></h2>
   <p>This appendix provides some sample code
    that can be used in encoding and decoding PNG chunks.
    It does not form a part of the specification.
    In the event of a discrepancy
    between the sample code in this appendix
    and the chunk definition,
    the chunk definition prevails.</p>
   <h3 class="heading settled" data-level="9.1" id="SC.pCAL"><span class="secno">9.1. </span><span class="content"> <span class="chunk">pCAL</span> Sample code </span><a class="self-link" href="#SC.pCAL"></a></h3>
<pre class="include-code highlight">   <c- cp>#if 0</c->
<c- c>   pcal.c 0.2.2 (Sat 19 Dec 1998)</c->
<c- c>   Adam M. Costello &lt;amc @ cs.berkeley.edu></c->

<c- c>   This is public domain example code for computing</c->
<c- c>   the mappings defined for the PNG pCAL chunk.</c->

<c- cp>   #endif</c->
   <c- cp>#if __STDC__ != 1</c->
   <c- cp>#error This code relies on ANSI C conformance.</c->
   <c- cp>#endif</c->


   <c- cp>#include</c-> &lt;limits.h>
   <c- cp>#include</c-> &lt;math.h>
   <c- cp>#include</c-> &lt;stdio.h>
   <c- cp>#include</c-> &lt;stdlib.h>


   <c- d>/* In this program a type named uintN denotes an unsigned    */</c->
   <c- d>/* type that handles at least all values 0 through (2^N)-1.  */</c->
   <c- d>/* A type named intN denotes a signed type that handles at   */</c->
   <c- d>/* least all values 1-2^(N-1) through 2^(N-1)-1.  It is not  */</c->
   <c- d>/* necessarily the smallest such type; we are more concerned */</c->
   <c- d>/* with speed.                                               */</c->

   <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint16</c-><c- p>;</c->

   <c- cp>#if UINT_MAX >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint32</c-><c- p>;</c->
   <c- cp>#else</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- n>uint32</c-><c- p>;</c->
   <c- cp>#endif</c->

   <c- cp>#if INT_MAX >= 0x7fffffff &amp;&amp; INT_MIN + 0x7fffffff &lt;= 0</c->
     <c- k>typedef</c-> <c- b>int</c-> <c- n>int32</c-><c- p>;</c->
   <c- cp>#else</c->
     <c- k>typedef</c-> <c- b>long</c-> <c- n>int32</c-><c- p>;</c->
   <c- cp>#endif</c->

   <c- d>/* Testing for 48-bit integers is tricky because we cannot */</c->
   <c- d>/* safely use constants greater than 0xffffffff.  Also,    */</c->
   <c- d>/* shifting by the entire width of a type is undefined, so */</c->
   <c- d>/* for unsigned int, which might be only 16 bits wide, we  */</c->
   <c- d>/* must shift in two steps.                                */</c->

   <c- cp>#if (UINT_MAX - 0xffff) >> 8 >> 8 >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint48</c-><c- p>;</c->
     <c- cp>#define HAVE_UINT48 1</c->
   <c- cp>#elif (ULONG_MAX - 0xffff) >> 16 >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- n>uint48</c-><c- p>;</c->
     <c- cp>#define HAVE_UINT48 1</c->
   <c- cp>#elif defined(ULLONG_MAX)</c->
     <c- cp>#if (ULLONG_MAX - 0xffff) >> 16 >= 0xffffffff</c->
       <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-> <c- n>uint48</c-><c- p>;</c->
       <c- cp>#define HAVE_UINT48 1</c->
     <c- cp>#endif</c->
   <c- cp>#else</c->
     <c- cp>#define HAVE_UINT48 0</c->
   <c- cp>#endif</c->


   <c- d>/*******************/</c->
   <c- d>/* Program failure */</c->

   <c- b>void</c->
   <c- nf>fail</c-><c- p>(</c-><c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>msg</c-><c- p>)</c->
   <c- p>{</c->
     <c- n>fputs</c-><c- p>(</c-><c- n>msg</c-><c- p>,</c-><c- n>stderr</c-><c- p>);</c->
     <c- n>fputc</c-><c- p>(</c-><c- sc>'\n'</c-><c- p>,</c-> <c- n>stderr</c-><c- p>);</c->
     <c- n>exit</c-><c- p>(</c-><c- n>EXIT_FAILURE</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/*************************/</c->
   <c- d>/* Check max, x0, and x1 */</c->

   <c- b>int</c->
   <c- nf>samp_params_ok</c-><c- p>(</c-><c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- d>/* Returns 1 if max, x0, and x1 have */</c->
   <c- d>/* allowed values, 0 otherwise.      */</c->

   <c- p>{</c->
     <c- k>const</c-> <c- n>int32</c-> <c- n>xlimit</c-> <c- o>=</c-> <c- mh>0x7fffffff</c-><c- p>;</c->

     <c- k>return</c->    <c- n>max</c-> <c- o>></c->  <c- mi>0</c->      <c- o>&amp;&amp;</c-> <c- n>max</c-> <c- o>&lt;=</c->  <c- mh>0xffff</c->
            <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>&lt;=</c-> <c- n>xlimit</c-> <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>>=</c-> <c- o>-</c-><c- n>xlimit</c->
            <c- o>&amp;&amp;</c->  <c- n>x1</c-> <c- o>&lt;=</c-> <c- n>xlimit</c-> <c- o>&amp;&amp;</c->  <c- n>x1</c-> <c- o>>=</c-> <c- o>-</c-><c- n>xlimit</c->
            <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>!=</c-> <c- n>x1</c-><c- p>;</c->
   <c- p>}</c->


   <c- d>/***********************************************/</c->
   <c- d>/* Map from stored samples to original samples */</c->

   <c- n>int32</c->
   <c- n>stored_to_orig</c-><c- p>(</c-><c- n>uint16</c-> <c- n>stored</c-><c- p>,</c-> <c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- cp>#if 0</c->

<c- c>     Returns the original sample corresponding to the given stored</c->
<c- c>     sample, which must be &lt;= max.  The parameters max, x0, and x1</c->
<c- c>     must have been approved by samp_params_ok().</c->

<c- c>     The pCAL spec says:</c->

<c- c>         orig = (stored * (x1-x0) + max/2) / max + x0           [1]</c->

<c- c>     Equivalently:</c->

<c- c>         orig = (stored * (x1-x0) + max/2) / max</c->
<c- c>                + (x0-x1) - (x0-x1) + x0</c->
<c- c>         orig = (stored * (x1-x0) + max * (x0-x1) + max/2) / max</c->
<c- c>                - (x0-x1) + x0</c->
<c- c>         orig = ((max - stored) * (x0-x1) + max/2) / max + x1</c->

<c- c>     So we can check whether x0 &lt; x1 and coerce the formula so that</c->
<c- c>     the numerators and denominators are always nonnegative:</c->

<c- c>         orig = (offset * xspan + max/2) / max + xbottom        [2]</c->

<c- c>     This will come in handy later.</c->

<c- c>     But the multiplication and the subtraction can overflow, so we</c->
<c- c>     have to be trickier.  For the subtraction, we can convert to</c->
<c- c>     unsigned integers.  For the multiplication, we can use 48-bit</c->
<c- c>     integers if we have them, otherwise observe that:</c->

<c- c>            b    =   (b/c)*c +     b%c</c->
<c- c>          a*b    = a*(b/c)*c +  a*(b%c)  ; let d = a*(b%c)</c->
<c- c>         (a*b)/c = a*(b/c)   +     d/c   remainder d%c          [3]</c->

<c- c>     These are true no matter which way the division rounds.  If</c->
<c- c>     (a*b)/c is in-range, a*(b/c) is guaranteed to be in-range if</c->
<c- c>     b/c rounds toward zero.  Here is another observation:</c->

<c- c>         sum{x_i} / c = sum{x_i / c} + sum{x_i % c} / c         [4]</c->

<c- c>     This one also avoids overflow if the division rounds toward</c->
<c- c>     zero.  The pCAL spec requires rounding toward -infinity.  ANSI</c->
<c- c>     C leaves the rounding direction implementation-defined except</c->
<c- c>     when both the numerator and denominator are nonnegative, in</c->
<c- c>     which case it rounds downward.  So if we arrange for all</c->
<c- c>     numerators and denominators to be nonnegative, everything</c->
<c- c>     works.  Starting with equation 2 and applying identity 4, then</c->
<c- c>     3, we obtain the final formula:</c->

<c- c>               d = offset * (xspan % max)</c->
<c- c>         xoffset = offset * (xspan / max) + d/max</c->
<c- c>                   + (d%max + max/2) / max</c->
<c- c>            orig = xoffset + xbottom</c->

<c- cp>   #endif</c->

   <c- p>{</c->
     <c- n>uint16</c-> <c- n>offset</c-><c- p>;</c->
     <c- n>uint32</c-> <c- n>xspan</c-><c- p>,</c-> <c- n>q</c-><c- p>,</c-> <c- n>r</c-><c- p>,</c-> <c- n>d</c-><c- p>,</c-> <c- n>xoffset</c-><c- p>;</c->
     <c- n>int32</c-> <c- n>xbottom</c-><c- p>;</c->

     <c- k>if</c-> <c- p>(</c-><c- n>stored</c-> <c- o>></c-> <c- n>max</c-><c- p>)</c-> <c- n>fail</c-><c- p>(</c-><c- s>"stored_to_orig: stored > max"</c-><c- p>);</c->

     <c- k>if</c-> <c- p>(</c-><c- n>x1</c-> <c- o>>=</c-> <c- n>x0</c-><c- p>)</c-> <c- p>{</c->
       <c- n>xbottom</c-> <c- o>=</c-> <c- n>x0</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
       <c- n>offset</c-> <c- o>=</c-> <c- n>stored</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- n>xbottom</c-> <c- o>=</c-> <c- n>x1</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-><c- p>;</c->
       <c- n>offset</c-> <c- o>=</c-> <c- n>max</c-> <c- o>-</c-> <c- n>stored</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* We knew xspan would fit in a uint32, but we needed to   */</c->
     <c- d>/* cast x0 and x1 before subtracting because otherwise the */</c->
     <c- d>/* subtraction could overflow, and ANSI doesn't say what   */</c->
     <c- d>/* the result will be in that case.                        */</c->

     <c- d>/* Let's optimize two common simple cases */</c->
     <c- d>/* before handling the general case:      */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>==</c-> <c- n>max</c-><c- p>)</c-> <c- p>{</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- n>offset</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>&lt;=</c-> <c- mh>0xffff</c-><c- p>)</c-> <c- p>{</c->
       <c- d>/* Equation 2 won't overflow and does only one division. */</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>offset</c-> <c- o>*</c-> <c- n>xspan</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- cp>#if HAVE_UINT48</c->
         <c- d>/* We can use equation 2 and do one uint48     */</c->
         <c- d>/* division instead of three uint32 divisions. */</c->
         <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>offset</c-> <c- o>*</c-> <c- p>(</c-><c- n>uint48</c-><c- p>)</c-><c- n>xspan</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
       <c- cp>#else</c->
         <c- n>q</c-> <c- o>=</c-> <c- n>xspan</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
         <c- n>r</c-> <c- o>=</c-> <c- n>xspan</c-> <c- o>%</c-> <c- n>max</c-><c- p>;</c->
         <c- d>/* Hopefully those were compiled into one instruction. */</c->
         <c- n>d</c-> <c- o>=</c-> <c- n>offset</c-> <c- o>*</c-> <c- n>r</c-><c- p>;</c->
         <c- n>xoffset</c-> <c- o>=</c-> <c- n>offset</c-> <c- o>*</c-> <c- n>q</c-> <c- o>+</c-> <c- n>d</c-><c- o>/</c-><c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>d</c-><c- o>%</c-><c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
       <c- cp>#endif</c->
     <c- p>}</c->

     <c- d>/* xoffset might not fit in an int32, but we know the sum */</c->
     <c- d>/* xbottom + xoffset will, so we can do the addition on   */</c->
     <c- d>/* unsigned integers and then cast.                       */</c->

     <c- k>return</c-> <c- p>(</c-><c- n>int32</c-><c- p>)((</c-><c- n>uint32</c-><c- p>)</c-><c- n>xbottom</c-> <c- o>+</c-> <c- n>xoffset</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/***********************************************/</c->
   <c- d>/* Map from original samples to stored samples */</c->

   <c- n>uint16</c->
   <c- n>orig_to_stored</c-><c- p>(</c-><c- n>int32</c-> <c- n>orig</c-><c- p>,</c-> <c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- cp>#if 0</c->

<c- c>     Returns the stored sample corresponding to the given original</c->
<c- c>     sample.  The parameters max, x0, and x1 must have been</c->
<c- c>     approved by samp_params_ok().</c->

<c- c>     The pCAL spec says:</c->

<c- c>     stored = ((orig - x0) * max + (x1-x0)/2) / (x1-x0)</c->
<c- c>              clipped to the range 0..max</c->

<c- c>     Notice that all three terms are nonnegative, or else all</c->
<c- c>     are nonpositive.  Just as in stored_to_orig(), we can avoid</c->
<c- c>     overflow and rounding problems by transforming the equation to</c->
<c- c>     use unsigned quantities:</c->

<c- c>     stored = (xoffset * max + xspan/2) / xspan</c->

<c- cp>   #endif</c->

   <c- p>{</c->
     <c- n>uint32</c-> <c- n>xoffset</c-><c- p>,</c-> <c- n>xspan</c-><c- p>;</c->

     <c- k>if</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;</c-> <c- n>x1</c-><c- p>)</c-> <c- p>{</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>&lt;</c-> <c- n>x0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>></c-> <c- n>x1</c-><c- p>)</c-> <c- k>return</c-> <c- n>max</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>orig</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>&lt;</c-> <c- n>x1</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>></c-> <c- n>x0</c-><c- p>)</c-> <c- k>return</c-> <c- n>max</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-><c- p>;</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>orig</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* For 16-bit xspan the calculation is straightforward: */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>&lt;=</c-> <c- mh>0xffff</c-><c- p>)</c->
       <c- k>return</c-> <c- p>(</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->

     <c- d>/* Otherwise, the numerator is more than 32 bits and the   */</c->
     <c- d>/* denominator is more than 16 bits.  The tricks we played */</c->
     <c- d>/* in stored_to_orig() depended on the denominator being   */</c->
     <c- d>/* 16-bit, so they won't help us here.                     */</c->

     <c- cp>#if HAVE_UINT48</c->
       <c- k>return</c-> <c- p>((</c-><c- n>uint48</c-><c- p>)</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->
     <c- cp>#else</c->

       <c- d>/* Doing the exact integer calculation with 32-bit         */</c->
       <c- d>/* arithmetic would be very difficult.  But xspan > 0xffff */</c->
       <c- d>/* implies xspan > max, in which case the pCAL spec says   */</c->
       <c- d>/* "there can be no lossless reversible mapping, but the   */</c->
       <c- d>/* functions provide the best integer approximations to    */</c->
       <c- d>/* floating-point affine transformations."  So why insist  */</c->
       <c- d>/* on using the integer calculation?  Let's just use       */</c->
       <c- d>/* floating-point.                                         */</c->

       <c- k>return</c-> <c- p>((</c-><c- b>double</c-><c- p>)</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->

     <c- cp>#endif</c->
   <c- p>}</c->


   <c- d>/*********************************************/</c->
   <c- d>/* Check x0, x1, eqtype, n, and p[0]..p[n-1] */</c->

   <c- b>int</c->
   <c- n>phys_params_ok</c-><c- p>(</c-><c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>,</c-> <c- b>int</c-> <c- n>eqtype</c-><c- p>,</c-> <c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>double</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c->

   <c- d>/* Returns 1 if x0, x1, eqtype, n, and p[0]..p[n-1] */</c->
   <c- d>/* have allowed values, 0 otherwise.                */</c->

   <c- p>{</c->
     <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>samp_params_ok</c-><c- p>(</c-><c- mi>1</c-><c- p>,</c-><c- n>x0</c-><c- p>,</c-><c- n>x1</c-><c- p>))</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->

     <c- k>switch</c-> <c- p>(</c-><c- n>eqtype</c-><c- p>)</c-> <c- p>{</c->
       <c- k>case</c-> <c- mi>0</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>2</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>1</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>3</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>2</c-><c- p>:</c-> <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>3</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>4</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* eqtype is 2, check for pow() domain error: */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>1</c-><c- p>;</c->
     <c- k>if</c-> <c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
     <c- k>return</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;=</c-> <c- n>x1</c-><c- p>)</c-> <c- o>?</c-> <c- p>(</c-><c- n>x0</c-> <c- o>></c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>x1</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>:</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;</c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>x1</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/************************************************/</c->
   <c- d>/* Map from original samples to physical values */</c->

   <c- b>double</c->
   <c- n>orig_to_phys</c-><c- p>(</c-><c- n>int32</c-> <c- n>orig</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>,</c->
                <c- b>int</c-> <c- n>eqtype</c-><c- p>,</c-> <c- b>double</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c->

   <c- d>/* Returns the physical value corresponding to the given    */</c->
   <c- d>/* original sample.  The parameters x0, x1, eqtype, and p[] */</c->
   <c- d>/* must have been approved by phys_params_ok().  The array  */</c->
   <c- d>/* p[] must hold enough parameters for the equation type.   */</c->

   <c- p>{</c->
     <c- b>double</c-> <c- n>xdiff</c-><c- p>,</c-> <c- n>f</c-><c- p>;</c->

     <c- n>xdiff</c-> <c- o>=</c-> <c- p>(</c-><c- b>double</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- n>x0</c-><c- p>;</c->

     <c- k>switch</c-> <c- p>(</c-><c- n>eqtype</c-><c- p>)</c-> <c- p>{</c->
       <c- k>case</c-> <c- mi>0</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>;</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>1</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>exp</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>*</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>2</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>pow</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>],</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>3</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>sinh</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>*</c-> <c- p>(</c-><c- n>orig</c-> <c- o>-</c-> <c- n>p</c-><c- p>[</c-><c- mi>3</c-><c- p>])</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>default</c-><c- o>:</c-> <c- n>fail</c-><c- p>(</c-><c- s>"orig_to_phys: unknown equation type"</c-><c- p>);</c->
     <c- p>}</c->

     <c- k>return</c-> <c- n>p</c-><c- p>[</c-><c- mi>0</c-><c- p>]</c-> <c- o>+</c-> <c- n>p</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>*</c-> <c- n>f</c-><c- p>;</c->
   <c- p>}</c-></pre>
   <h3 class="heading settled" data-level="9.2" id="SC.Fixed-point-gamma-corr"><span class="secno">9.2. </span><span class="content"> Fixed-point gamma correction </span><a class="self-link" href="#SC.Fixed-point-gamma-corr"></a></h3>
<pre class="include-code highlight">   <c- cp>#if 0</c->
<c- c>   pcal.c 0.2.2 (Sat 19 Dec 1998)</c->
<c- c>   Adam M. Costello &lt;amc @ cs.berkeley.edu></c->

<c- c>   This is public domain example code for computing</c->
<c- c>   the mappings defined for the PNG pCAL chunk.</c->

<c- cp>   #endif</c->
   <c- cp>#if __STDC__ != 1</c->
   <c- cp>#error This code relies on ANSI C conformance.</c->
   <c- cp>#endif</c->


   <c- cp>#include</c-> &lt;limits.h>
   <c- cp>#include</c-> &lt;math.h>
   <c- cp>#include</c-> &lt;stdio.h>
   <c- cp>#include</c-> &lt;stdlib.h>


   <c- d>/* In this program a type named uintN denotes an unsigned    */</c->
   <c- d>/* type that handles at least all values 0 through (2^N)-1.  */</c->
   <c- d>/* A type named intN denotes a signed type that handles at   */</c->
   <c- d>/* least all values 1-2^(N-1) through 2^(N-1)-1.  It is not  */</c->
   <c- d>/* necessarily the smallest such type; we are more concerned */</c->
   <c- d>/* with speed.                                               */</c->

   <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint16</c-><c- p>;</c->

   <c- cp>#if UINT_MAX >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint32</c-><c- p>;</c->
   <c- cp>#else</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- n>uint32</c-><c- p>;</c->
   <c- cp>#endif</c->

   <c- cp>#if INT_MAX >= 0x7fffffff &amp;&amp; INT_MIN + 0x7fffffff &lt;= 0</c->
     <c- k>typedef</c-> <c- b>int</c-> <c- n>int32</c-><c- p>;</c->
   <c- cp>#else</c->
     <c- k>typedef</c-> <c- b>long</c-> <c- n>int32</c-><c- p>;</c->
   <c- cp>#endif</c->

   <c- d>/* Testing for 48-bit integers is tricky because we cannot */</c->
   <c- d>/* safely use constants greater than 0xffffffff.  Also,    */</c->
   <c- d>/* shifting by the entire width of a type is undefined, so */</c->
   <c- d>/* for unsigned int, which might be only 16 bits wide, we  */</c->
   <c- d>/* must shift in two steps.                                */</c->

   <c- cp>#if (UINT_MAX - 0xffff) >> 8 >> 8 >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>int</c-> <c- n>uint48</c-><c- p>;</c->
     <c- cp>#define HAVE_UINT48 1</c->
   <c- cp>#elif (ULONG_MAX - 0xffff) >> 16 >= 0xffffffff</c->
     <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- n>uint48</c-><c- p>;</c->
     <c- cp>#define HAVE_UINT48 1</c->
   <c- cp>#elif defined(ULLONG_MAX)</c->
     <c- cp>#if (ULLONG_MAX - 0xffff) >> 16 >= 0xffffffff</c->
       <c- k>typedef</c-> <c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-> <c- n>uint48</c-><c- p>;</c->
       <c- cp>#define HAVE_UINT48 1</c->
     <c- cp>#endif</c->
   <c- cp>#else</c->
     <c- cp>#define HAVE_UINT48 0</c->
   <c- cp>#endif</c->


   <c- d>/*******************/</c->
   <c- d>/* Program failure */</c->

   <c- b>void</c->
   <c- nf>fail</c-><c- p>(</c-><c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>msg</c-><c- p>)</c->
   <c- p>{</c->
     <c- n>fputs</c-><c- p>(</c-><c- n>msg</c-><c- p>,</c-><c- n>stderr</c-><c- p>);</c->
     <c- n>fputc</c-><c- p>(</c-><c- sc>'\n'</c-><c- p>,</c-> <c- n>stderr</c-><c- p>);</c->
     <c- n>exit</c-><c- p>(</c-><c- n>EXIT_FAILURE</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/*************************/</c->
   <c- d>/* Check max, x0, and x1 */</c->

   <c- b>int</c->
   <c- nf>samp_params_ok</c-><c- p>(</c-><c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- d>/* Returns 1 if max, x0, and x1 have */</c->
   <c- d>/* allowed values, 0 otherwise.      */</c->

   <c- p>{</c->
     <c- k>const</c-> <c- n>int32</c-> <c- n>xlimit</c-> <c- o>=</c-> <c- mh>0x7fffffff</c-><c- p>;</c->

     <c- k>return</c->    <c- n>max</c-> <c- o>></c->  <c- mi>0</c->      <c- o>&amp;&amp;</c-> <c- n>max</c-> <c- o>&lt;=</c->  <c- mh>0xffff</c->
            <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>&lt;=</c-> <c- n>xlimit</c-> <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>>=</c-> <c- o>-</c-><c- n>xlimit</c->
            <c- o>&amp;&amp;</c->  <c- n>x1</c-> <c- o>&lt;=</c-> <c- n>xlimit</c-> <c- o>&amp;&amp;</c->  <c- n>x1</c-> <c- o>>=</c-> <c- o>-</c-><c- n>xlimit</c->
            <c- o>&amp;&amp;</c->  <c- n>x0</c-> <c- o>!=</c-> <c- n>x1</c-><c- p>;</c->
   <c- p>}</c->


   <c- d>/***********************************************/</c->
   <c- d>/* Map from stored samples to original samples */</c->

   <c- n>int32</c->
   <c- n>stored_to_orig</c-><c- p>(</c-><c- n>uint16</c-> <c- n>stored</c-><c- p>,</c-> <c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- cp>#if 0</c->

<c- c>     Returns the original sample corresponding to the given stored</c->
<c- c>     sample, which must be &lt;= max.  The parameters max, x0, and x1</c->
<c- c>     must have been approved by samp_params_ok().</c->

<c- c>     The pCAL spec says:</c->

<c- c>         orig = (stored * (x1-x0) + max/2) / max + x0           [1]</c->

<c- c>     Equivalently:</c->

<c- c>         orig = (stored * (x1-x0) + max/2) / max</c->
<c- c>                + (x0-x1) - (x0-x1) + x0</c->
<c- c>         orig = (stored * (x1-x0) + max * (x0-x1) + max/2) / max</c->
<c- c>                - (x0-x1) + x0</c->
<c- c>         orig = ((max - stored) * (x0-x1) + max/2) / max + x1</c->

<c- c>     So we can check whether x0 &lt; x1 and coerce the formula so that</c->
<c- c>     the numerators and denominators are always nonnegative:</c->

<c- c>         orig = (offset * xspan + max/2) / max + xbottom        [2]</c->

<c- c>     This will come in handy later.</c->

<c- c>     But the multiplication and the subtraction can overflow, so we</c->
<c- c>     have to be trickier.  For the subtraction, we can convert to</c->
<c- c>     unsigned integers.  For the multiplication, we can use 48-bit</c->
<c- c>     integers if we have them, otherwise observe that:</c->

<c- c>            b    =   (b/c)*c +     b%c</c->
<c- c>          a*b    = a*(b/c)*c +  a*(b%c)  ; let d = a*(b%c)</c->
<c- c>         (a*b)/c = a*(b/c)   +     d/c   remainder d%c          [3]</c->

<c- c>     These are true no matter which way the division rounds.  If</c->
<c- c>     (a*b)/c is in-range, a*(b/c) is guaranteed to be in-range if</c->
<c- c>     b/c rounds toward zero.  Here is another observation:</c->

<c- c>         sum{x_i} / c = sum{x_i / c} + sum{x_i % c} / c         [4]</c->

<c- c>     This one also avoids overflow if the division rounds toward</c->
<c- c>     zero.  The pCAL spec requires rounding toward -infinity.  ANSI</c->
<c- c>     C leaves the rounding direction implementation-defined except</c->
<c- c>     when both the numerator and denominator are nonnegative, in</c->
<c- c>     which case it rounds downward.  So if we arrange for all</c->
<c- c>     numerators and denominators to be nonnegative, everything</c->
<c- c>     works.  Starting with equation 2 and applying identity 4, then</c->
<c- c>     3, we obtain the final formula:</c->

<c- c>               d = offset * (xspan % max)</c->
<c- c>         xoffset = offset * (xspan / max) + d/max</c->
<c- c>                   + (d%max + max/2) / max</c->
<c- c>            orig = xoffset + xbottom</c->

<c- cp>   #endif</c->

   <c- p>{</c->
     <c- n>uint16</c-> <c- n>offset</c-><c- p>;</c->
     <c- n>uint32</c-> <c- n>xspan</c-><c- p>,</c-> <c- n>q</c-><c- p>,</c-> <c- n>r</c-><c- p>,</c-> <c- n>d</c-><c- p>,</c-> <c- n>xoffset</c-><c- p>;</c->
     <c- n>int32</c-> <c- n>xbottom</c-><c- p>;</c->

     <c- k>if</c-> <c- p>(</c-><c- n>stored</c-> <c- o>></c-> <c- n>max</c-><c- p>)</c-> <c- n>fail</c-><c- p>(</c-><c- s>"stored_to_orig: stored > max"</c-><c- p>);</c->

     <c- k>if</c-> <c- p>(</c-><c- n>x1</c-> <c- o>>=</c-> <c- n>x0</c-><c- p>)</c-> <c- p>{</c->
       <c- n>xbottom</c-> <c- o>=</c-> <c- n>x0</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
       <c- n>offset</c-> <c- o>=</c-> <c- n>stored</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- n>xbottom</c-> <c- o>=</c-> <c- n>x1</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-><c- p>;</c->
       <c- n>offset</c-> <c- o>=</c-> <c- n>max</c-> <c- o>-</c-> <c- n>stored</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* We knew xspan would fit in a uint32, but we needed to   */</c->
     <c- d>/* cast x0 and x1 before subtracting because otherwise the */</c->
     <c- d>/* subtraction could overflow, and ANSI doesn't say what   */</c->
     <c- d>/* the result will be in that case.                        */</c->

     <c- d>/* Let's optimize two common simple cases */</c->
     <c- d>/* before handling the general case:      */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>==</c-> <c- n>max</c-><c- p>)</c-> <c- p>{</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- n>offset</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>&lt;=</c-> <c- mh>0xffff</c-><c- p>)</c-> <c- p>{</c->
       <c- d>/* Equation 2 won't overflow and does only one division. */</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>offset</c-> <c- o>*</c-> <c- n>xspan</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- cp>#if HAVE_UINT48</c->
         <c- d>/* We can use equation 2 and do one uint48     */</c->
         <c- d>/* division instead of three uint32 divisions. */</c->
         <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>offset</c-> <c- o>*</c-> <c- p>(</c-><c- n>uint48</c-><c- p>)</c-><c- n>xspan</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
       <c- cp>#else</c->
         <c- n>q</c-> <c- o>=</c-> <c- n>xspan</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
         <c- n>r</c-> <c- o>=</c-> <c- n>xspan</c-> <c- o>%</c-> <c- n>max</c-><c- p>;</c->
         <c- d>/* Hopefully those were compiled into one instruction. */</c->
         <c- n>d</c-> <c- o>=</c-> <c- n>offset</c-> <c- o>*</c-> <c- n>r</c-><c- p>;</c->
         <c- n>xoffset</c-> <c- o>=</c-> <c- n>offset</c-> <c- o>*</c-> <c- n>q</c-> <c- o>+</c-> <c- n>d</c-><c- o>/</c-><c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>d</c-><c- o>%</c-><c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>max</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>max</c-><c- p>;</c->
       <c- cp>#endif</c->
     <c- p>}</c->

     <c- d>/* xoffset might not fit in an int32, but we know the sum */</c->
     <c- d>/* xbottom + xoffset will, so we can do the addition on   */</c->
     <c- d>/* unsigned integers and then cast.                       */</c->

     <c- k>return</c-> <c- p>(</c-><c- n>int32</c-><c- p>)((</c-><c- n>uint32</c-><c- p>)</c-><c- n>xbottom</c-> <c- o>+</c-> <c- n>xoffset</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/***********************************************/</c->
   <c- d>/* Map from original samples to stored samples */</c->

   <c- n>uint16</c->
   <c- n>orig_to_stored</c-><c- p>(</c-><c- n>int32</c-> <c- n>orig</c-><c- p>,</c-> <c- n>uint16</c-> <c- n>max</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>)</c->

   <c- cp>#if 0</c->

<c- c>     Returns the stored sample corresponding to the given original</c->
<c- c>     sample.  The parameters max, x0, and x1 must have been</c->
<c- c>     approved by samp_params_ok().</c->

<c- c>     The pCAL spec says:</c->

<c- c>     stored = ((orig - x0) * max + (x1-x0)/2) / (x1-x0)</c->
<c- c>              clipped to the range 0..max</c->

<c- c>     Notice that all three terms are nonnegative, or else all</c->
<c- c>     are nonpositive.  Just as in stored_to_orig(), we can avoid</c->
<c- c>     overflow and rounding problems by transforming the equation to</c->
<c- c>     use unsigned quantities:</c->

<c- c>     stored = (xoffset * max + xspan/2) / xspan</c->

<c- cp>   #endif</c->

   <c- p>{</c->
     <c- n>uint32</c-> <c- n>xoffset</c-><c- p>,</c-> <c- n>xspan</c-><c- p>;</c->

     <c- k>if</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;</c-> <c- n>x1</c-><c- p>)</c-> <c- p>{</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>&lt;</c-> <c- n>x0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>></c-> <c- n>x1</c-><c- p>)</c-> <c- k>return</c-> <c- n>max</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>orig</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-><c- p>;</c->
     <c- p>}</c->
     <c- k>else</c-> <c- p>{</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>&lt;</c-> <c- n>x1</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
       <c- k>if</c-> <c- p>(</c-><c- n>orig</c-> <c- o>></c-> <c- n>x0</c-><c- p>)</c-> <c- k>return</c-> <c- n>max</c-><c- p>;</c->
       <c- n>xspan</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x1</c-><c- p>;</c->
       <c- n>xoffset</c-> <c- o>=</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>x0</c-> <c- o>-</c-> <c- p>(</c-><c- n>uint32</c-><c- p>)</c-><c- n>orig</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* For 16-bit xspan the calculation is straightforward: */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>xspan</c-> <c- o>&lt;=</c-> <c- mh>0xffff</c-><c- p>)</c->
       <c- k>return</c-> <c- p>(</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->

     <c- d>/* Otherwise, the numerator is more than 32 bits and the   */</c->
     <c- d>/* denominator is more than 16 bits.  The tricks we played */</c->
     <c- d>/* in stored_to_orig() depended on the denominator being   */</c->
     <c- d>/* 16-bit, so they won't help us here.                     */</c->

     <c- cp>#if HAVE_UINT48</c->
       <c- k>return</c-> <c- p>((</c-><c- n>uint48</c-><c- p>)</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->
     <c- cp>#else</c->

       <c- d>/* Doing the exact integer calculation with 32-bit         */</c->
       <c- d>/* arithmetic would be very difficult.  But xspan > 0xffff */</c->
       <c- d>/* implies xspan > max, in which case the pCAL spec says   */</c->
       <c- d>/* "there can be no lossless reversible mapping, but the   */</c->
       <c- d>/* functions provide the best integer approximations to    */</c->
       <c- d>/* floating-point affine transformations."  So why insist  */</c->
       <c- d>/* on using the integer calculation?  Let's just use       */</c->
       <c- d>/* floating-point.                                         */</c->

       <c- k>return</c-> <c- p>((</c-><c- b>double</c-><c- p>)</c-><c- n>xoffset</c-> <c- o>*</c-> <c- n>max</c-> <c- o>+</c-> <c- p>(</c-><c- n>xspan</c-><c- o>>></c-><c- mi>1</c-><c- p>))</c-> <c- o>/</c-> <c- n>xspan</c-><c- p>;</c->

     <c- cp>#endif</c->
   <c- p>}</c->


   <c- d>/*********************************************/</c->
   <c- d>/* Check x0, x1, eqtype, n, and p[0]..p[n-1] */</c->

   <c- b>int</c->
   <c- n>phys_params_ok</c-><c- p>(</c-><c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>,</c-> <c- b>int</c-> <c- n>eqtype</c-><c- p>,</c-> <c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>double</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c->

   <c- d>/* Returns 1 if x0, x1, eqtype, n, and p[0]..p[n-1] */</c->
   <c- d>/* have allowed values, 0 otherwise.                */</c->

   <c- p>{</c->
     <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>samp_params_ok</c-><c- p>(</c-><c- mi>1</c-><c- p>,</c-><c- n>x0</c-><c- p>,</c-><c- n>x1</c-><c- p>))</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->

     <c- k>switch</c-> <c- p>(</c-><c- n>eqtype</c-><c- p>)</c-> <c- p>{</c->
       <c- k>case</c-> <c- mi>0</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>2</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>1</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>3</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>2</c-><c- p>:</c-> <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>3</c-><c- p>:</c-> <c- k>return</c-> <c- n>n</c-> <c- o>==</c-> <c- mi>4</c-><c- p>;</c->
     <c- p>}</c->

     <c- d>/* eqtype is 2, check for pow() domain error: */</c->

     <c- k>if</c-> <c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>1</c-><c- p>;</c->
     <c- k>if</c-> <c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>)</c-> <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
     <c- k>return</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;=</c-> <c- n>x1</c-><c- p>)</c-> <c- o>?</c-> <c- p>(</c-><c- n>x0</c-> <c- o>></c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>x1</c-> <c- o>></c-> <c- mi>0</c-><c- p>)</c-> <c- o>:</c-> <c- p>(</c-><c- n>x0</c-> <c- o>&lt;</c-> <c- mi>0</c-> <c- o>&amp;&amp;</c-> <c- n>x1</c-> <c- o>&lt;</c-> <c- mi>0</c-><c- p>);</c->
   <c- p>}</c->


   <c- d>/************************************************/</c->
   <c- d>/* Map from original samples to physical values */</c->

   <c- b>double</c->
   <c- n>orig_to_phys</c-><c- p>(</c-><c- n>int32</c-> <c- n>orig</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x0</c-><c- p>,</c-> <c- n>int32</c-> <c- n>x1</c-><c- p>,</c->
                <c- b>int</c-> <c- n>eqtype</c-><c- p>,</c-> <c- b>double</c-> <c- o>*</c-><c- n>p</c-><c- p>)</c->

   <c- d>/* Returns the physical value corresponding to the given    */</c->
   <c- d>/* original sample.  The parameters x0, x1, eqtype, and p[] */</c->
   <c- d>/* must have been approved by phys_params_ok().  The array  */</c->
   <c- d>/* p[] must hold enough parameters for the equation type.   */</c->

   <c- p>{</c->
     <c- b>double</c-> <c- n>xdiff</c-><c- p>,</c-> <c- n>f</c-><c- p>;</c->

     <c- n>xdiff</c-> <c- o>=</c-> <c- p>(</c-><c- b>double</c-><c- p>)</c-><c- n>x1</c-> <c- o>-</c-> <c- n>x0</c-><c- p>;</c->

     <c- k>switch</c-> <c- p>(</c-><c- n>eqtype</c-><c- p>)</c-> <c- p>{</c->
       <c- k>case</c-> <c- mi>0</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>;</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>1</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>exp</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>*</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>2</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>pow</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>],</c-> <c- n>orig</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>case</c-> <c- mi>3</c-><c- p>:</c->  <c- n>f</c-> <c- o>=</c-> <c- n>sinh</c-><c- p>(</c-><c- n>p</c-><c- p>[</c-><c- mi>2</c-><c- p>]</c-> <c- o>*</c-> <c- p>(</c-><c- n>orig</c-> <c- o>-</c-> <c- n>p</c-><c- p>[</c-><c- mi>3</c-><c- p>])</c-> <c- o>/</c-> <c- n>xdiff</c-><c- p>);</c->
                <c- k>break</c-><c- p>;</c->
       <c- k>default</c-><c- o>:</c-> <c- n>fail</c-><c- p>(</c-><c- s>"orig_to_phys: unknown equation type"</c-><c- p>);</c->
     <c- p>}</c->

     <c- k>return</c-> <c- n>p</c-><c- p>[</c-><c- mi>0</c-><c- p>]</c-> <c- o>+</c-> <c- n>p</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>*</c-> <c- n>f</c-><c- p>;</c->
   <c- p>}</c-></pre>
   <h2 class="heading settled" data-level="10" id="Rationale"><span class="secno">10. </span><span class="content"> Rationale </span><a class="self-link" href="#Rationale"></a></h2>
   <h3 class="heading settled" data-level="10.1" id="R.pCAL"><span class="secno">10.1. </span><span class="content"> pCAL Rationale </span><a class="self-link" href="#R.pCAL"></a></h3>
   <p>This section gives the reasoning behind
    some of the design decisions
    in the pCAL chunk.
    It does not form a part of the specification.</p>
   <h4 class="heading settled" data-level="10.1.1" id="pCAL.red"><span class="secno">10.1.1. </span><span class="content"> Redundant equation types </span><a class="self-link" href="#pCAL.red"></a></h4>
   <p>Equation types 1 and 2 seem to be equivalent.
    Why have both?</p>
   <p>We don’t want to force people
    to do the exponentiation using <code>ln()</code> and <code>exp()</code>, since <code>pow()</code> may provide better accuracy
    in some floating-point math libraries.
    We also don’t want to force people
    using base-10 logs
    to store a sufficiently accurate value
    of <code>ln(10)</code> in the <span class="chunk">pCAL</span> chunk.</p>
   <p>When the base is <code>e</code>,
    we don’t want to force people
    to encode a sufficiently accurate value
    of <code>e</code> in the <span class="chunk">pCAL</span> chunk,
    or to use <code>pow()</code> when <code>exp()</code> is sufficient.</p>
   <h4 class="heading settled" data-level="10.1.2" id="pCAL.x0x1"><span class="secno">10.1.2. </span><span class="content"> What are <code>x0</code> and <code>x1</code> for? </span><a class="self-link" href="#pCAL.x0x1"></a></h4>
   <p>First, <code>x0</code> and <code>x1</code> provide a way
    to recover the original data,
    losslessly,
    when the original range is not a power of two.
    Sometimes the digitized values
    do not have a range that fills the full depth of a PNG.</p>
   <div class="example" id="example-38170b86"><a class="self-link" href="#example-38170b86"></a> For example, if the original samples
    range from 0 (corresponding to black)
    to 800 (corresponding to white),
    PNG requires that these samples be scaled
    to the range 0 to 65535.
    By recording <code>x0=0</code> and <code>x1=800 </code> we can recover the original samples,
    and we indicate the precision of the data. </div>
   <p>Even if the original data had a range
    identical to a valid PNG image sample,
    like 0 (black) to 65535 (white),
    one might want to create a derived image
    by stretching the contrast
    in a limited intensity range
    containing the important details.</p>
   <div class="example" id="example-cdc4fa32"><a class="self-link" href="#example-cdc4fa32"></a> For example,
    we might want to scale the samples
    so that 46000 becomes 0 (black) and
    47000 becomes 65535 (white).
    As in the previous case,
    by recording <code>x0=46000</code> and <code>x1.4.200</code>,
    we can recover the original data samples
    that fell between 46000 and 47000. </div>
   <h4 class="heading settled" data-level="10.1.3" id="pCAL.division"><span class="secno">10.1.3. </span><span class="content"> Integer division </span><a class="self-link" href="#pCAL.division"></a></h4>
   <p>Why define integer divison
    to round toward negative infinity?
    This is different from many C implementations
    and from all Fortran implementations,
    which round toward zero.</p>
   <p>We cannot leave the choice unspecified.
    If we were to specify rounding toward zero,
    we’d have to account for a discontinuity
    at zero.
    A division by positive <code>d</code> would map the <code>2d-1</code> values from <code>-(d-1)</code> through <code>d-1</code> to zero,
    but would map only <code>d</code> values
    to any other value;
    for example, <code>3d</code> through <code>4d-1</code> would be mapped to 3.
    Achieving lossless mappings
    in spite of this anomaly
    would be difficult.</p>
   <h2 class="heading settled" data-level="11" id="History"><span class="secno">11. </span><span class="content"> Appendix: Revision History </span><a class="self-link" href="#History"></a></h2>
   <ul>
    <li>24 Jan Dec 2022 (version 1.6.0)
    <ul>
     <li>Moved <span class="chunk">eXIF</span> to main PNG document
     <li>Converted source document to Bikeshed
    </ul>
    <li>
     15 July 2017 (version 1.5.0) 
     <ul>
      <li> Added the <code>eXIf</code> chunk 
      <li> Replaced ftp://www.simplesystems.org/pub/png/documents/ URL
    with http://libpng.download/documents/ 
     </ul>
    <li>
     12 June 2017 (version 1.4.1): 
     <ul>
      <li>Changed "name=" markup to "id=" in order to pass w3c validation 
      <li>Removed incorrect nroff-style page numbers from Table of Contents 
      <li>Added internal links in the Table of Contents 
      <li>Added reference to RFC-2119 for interpretation of "should", etc. 
      <li>Removed trailing blanks 
      <li>Added "Collection" keyword which was approved in 2004. 
      <li>Added Cosmin Truta (who suggested the Collection keyword) to Credits 
     </ul>
    <li>
     1 May 2008 (version 1.4.0): 
     <ul>
      <li>Added the <code>dSIG</code> chunk. 
     </ul>
    <li>
     31 August 2006 (version 1.3.0): 
     <ul>
      <li>Added the <code>sTER</code> chunk. 
     </ul>
    <li>
     14 July 1999 (version 1.2.0): 
     <ul>
      <li>Deleted the <code>iTXt</code> chunk, which has been moved to the core spec. 
     </ul>
    <li>
     9 February 1999 (version 1.1.1): 
     <ul>
      <li>Added the <code>iTXt</code> chunk 
      <li>Limited the character set for future registered keywords 
     </ul>
    <li>
     30 December 1998 (version 1.1.0): 
     <ul>
      <li>Added <code>pCAL</code> chunk and related sample code 
      <li>Deprecated the <code>gIFT</code> chunk 
      <li>Added sample gamma-correction code that uses integer arithmetic 
     </ul>
    <li>11 March 1996 (version 0.96): First public release 
   </ul>
   <h2 class="heading settled" data-level="12" id="Credits"><span class="secno">12. </span><span class="content"> Credits </span><a class="self-link" href="#Credits"></a></h2>
   <h3 class="heading settled" data-level="12.1" id="Credits.editors"><span class="secno">12.1. </span><span class="content"> Editors </span><a class="self-link" href="#Credits.editors"></a></h3>
   <ul>
    <li data-md>
     <p>Chris Lilley, chris @ w3.org</p>
    <li data-md>
     <p>Glenn Randers-Pehrson, glennrp @ users.sourceforge.net (versions 1.1 to 1.5)</p>
    <li data-md>
     <p>Tom Lane, tgl @ sss.pgh.pa.us (edited the first release of this document)</p>
   </ul>
   <h3 class="heading settled" data-level="12.2" id="Credits.contrib"><span class="secno">12.2. </span><span class="content"> Contributors </span><a class="self-link" href="#Credits.contrib"></a></h3>
   <p>Names of contributors
    not already listed in the PNG specification
    are presented in alphabetical order:</p>
   <ul>
    <li>Adeluc, <a href="http://www.adeluc.com">www.adeluc.com</a>,
    png @ adeluc.com 
    <li>Brendan Bolles 
    <li>Todd French, <code>tfrench @ sandia.gov</code> 
    <li>Phil Harvey 
    <li>Nancy M. Randers-Pehrson 
    <li>Alaric B. Snell, <code>alaric @ alaric-snell.com</code> 
    <li>Michael Stokes 
    <li>Jason Summers 
    <li>Cosmin Truta, <code>cosmin @ cs.toronto.edu</code> 
    <li>Pavel Zlatovratskii 
   </ul>
   <h3 class="heading settled" data-level="12.3" id="Credits.marks"><span class="secno">12.3. </span><span class="content"> Trademarks </span><a class="self-link" href="#Credits.marks"></a></h3>
   <p>GIF is a service mark of CompuServe Incorporated.
    PostScript is a trademark of Adobe Systems. </p>
  </main>
  <div data-fill-with="conformance">
   <h2 class="no-ref no-num heading settled" id="w3c-conformance"><span class="content">Conformance</span><a class="self-link" href="#w3c-conformance"></a></h2>
   <h3 class="no-ref no-num heading settled" id="w3c-conventions"><span class="content">Document conventions</span><a class="self-link" href="#w3c-conventions"></a></h3>
   <p>Conformance requirements are expressed
    with a combination of descriptive assertions
    and RFC 2119 terminology.
    The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”
    in the normative parts of this document
    are to be interpreted as described in RFC 2119.
    However, for readability,
    these words do not appear in all uppercase letters in this specification. </p>
   <p>All of the text of this specification is normative
    except sections explicitly marked as non-normative, examples, and notes. <a data-link-type="biblio" href="#biblio-rfc2119" title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</a> </p>
   <p>Examples in this specification are introduced with the words “for example”
    or are set apart from the normative text
    with <code>class="example"</code>,
    like this: </p>
   <div class="example" id="w3c-example">
    <a class="self-link" href="#w3c-example"></a> 
    <p>This is an example of an informative example. </p>
   </div>
   <p>Informative notes begin with the word “Note”
    and are set apart from the normative text
    with <code>class="note"</code>,
    like this: </p>
   <p class="note" role="note">Note, this is an informative note.</p>
  </div>
  <script src="https://www.w3.org/scripts/TR/2021/fixup.js"></script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
  <dl>
   <dt id="biblio-dsig-spec">[dSIG-spec]
   <dd>Thomas Kopp. <a href="http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.spec.pdf"><cite>PNG Digital Signatures: Extension Specification</cite></a>. 17 Nov 2008. URL: <a href="http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.spec.pdf">http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.spec.pdf</a>
   <dt id="biblio-idot-description">[iDOT-description]
   <dd>Dr. Neal Krawetz. <a href="https://www.hackerfactor.com/blog/index.php?/archives/895-Connecting-the-iDOTs.html"><cite>Connecting the iDOTs</cite></a>. 8 September 2020. URL: <a href="https://www.hackerfactor.com/blog/index.php?/archives/895-Connecting-the-iDOTs.html">https://www.hackerfactor.com/blog/index.php?/archives/895-Connecting-the-iDOTs.html</a>
   <dt id="biblio-iso646">[ISO646]
   <dd><a href="https://www.iso.org/standard/4777.html"><cite>Information technology — ISO 7-bit coded character set for information interchange</cite></a>. December 1991. Published. URL: <a href="https://www.iso.org/standard/4777.html">https://www.iso.org/standard/4777.html</a>
   <dt id="biblio-png">[PNG]
   <dd>Chris Lilley; et al. <a href="https://www.w3.org/TR/png-3/"><cite>Portable Network Graphics (PNG) Specification (Third Edition)</cite></a>. 24 June 2025. REC. URL: <a href="https://www.w3.org/TR/png-3/">https://www.w3.org/TR/png-3/</a>
   <dt id="biblio-rfc2119">[RFC2119]
   <dd>S. Bradner. <a href="https://datatracker.ietf.org/doc/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. March 1997. Best Current Practice. URL: <a href="https://datatracker.ietf.org/doc/html/rfc2119">https://datatracker.ietf.org/doc/html/rfc2119</a>
  </dl>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-dsig-example">[dSIG-example]
   <dd>Martin Boßlet; Thomas Kopp. <a href="http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.sample.html"><cite>PNG Digital Signatures: Commented Example</cite></a>. 18 May 2008. URL: <a href="http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.sample.html">http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.sample.html</a>
   <dt id="biblio-gif">[GIF]
   <dd><a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt"><cite>Graphics Interchange Format</cite></a>. 31 July 1990. URL: <a href="https://www.w3.org/Graphics/GIF/spec-gif89a.txt">https://www.w3.org/Graphics/GIF/spec-gif89a.txt</a>
  </dl>